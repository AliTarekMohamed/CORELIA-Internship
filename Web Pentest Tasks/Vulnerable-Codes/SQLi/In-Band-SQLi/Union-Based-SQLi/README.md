<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UNION-Based SQL Injection — Updated Walkthrough</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue",
                   Arial, "Noto Sans", "Liberation Sans", sans-serif;
      line-height: 1.6;
      margin: 2rem;
      color: #0b1220;
      background: #f7fafc;
    }
    .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 1.6rem; border-radius: 10px; box-shadow: 0 6px 18px rgba(11,18,32,0.06); }
    h1 { font-size: 1.8rem; margin-bottom: 0.2rem; }
    h2 { margin-top: 1.2rem; font-size: 1.2rem; }
    p.lead { color: #374151; }
    pre { background: #0f1724; color: #e6eef8; padding: 1rem; border-radius: 6px; overflow-x: auto; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; }
    blockquote { border-left: 4px solid #e2e8f0; margin: 0; padding-left: 1rem; color: #475569; background: #f1f5f9; border-radius: 6px; padding: 0.75rem 1rem; }
    ul, ol { margin-left: 1.1rem; }
    .badge { display:inline-block; padding:0.15rem 0.5rem; border-radius: 999px; background:#eef2ff; color:#3730a3; font-weight:600; font-size:0.8rem; margin-right:0.4rem; }
    .note { font-size: 0.95rem; color:#374151; background:#fff7ed; padding:0.6rem; border-radius:6px; border:1px solid #fde3b7; }
    footer { margin-top: 1.4rem; font-size: 0.9rem; color: #6b7280; }
  </style>
</head>
<body>
  <div class="container">
    <h1>UNION-Based SQL Injection — Updated Walkthrough</h1>

    <p class="lead">
      A concise, step-by-step UNION-based SQL injection example demonstrating how to discover column counts,
      enumerate schema objects, and extract data from a vulnerable search endpoint.
    </p>

    <h2>Quick summary</h2>
    <p>
      <span class="badge">Target</span>Search parameter of a web application that queries a database with a <code>games</code> resource.<br>
      <span class="badge">New discovery</span>Found a <code>users</code> table containing <code>username</code> and <code>password</code> columns; credential values were exfiltrated in the lab environment.<br>
      <span class="badge">Goal</span>Discover original query shape (number of returned columns), enumerate schema (table/column names), and extract values (e.g., username, password)
    </p>

    <h2>Summary of updated findings</h2>
    <ul>
      <li>Application vulnerable to UNION-based SQL injection via the search parameter.</li>
      <li>Original SELECT returns <strong>one</strong> column (required single-column UNION payloads).</li>
      <li>Discovered an additional table: <code>users</code>.</li>
      <li>Discovered columns in <code>users</code>: <code>username</code> and <code>password</code>.</li>
      <li>Credential values (usernames and passwords) were retrieved in the lab using a UNION payload that concatenates the fields into the single returned column.</li>
    </ul>

    <h2>Testing steps</h2>
    <ol>
      <li>
        <strong>Single-quote probe</strong><br>
        Inject a single quote (<code>'</code>) to observe application error behavior and whether errors are leaked.
        In this test, there were no visible SQL errors or unusual responses.
      </li>

      <li>
        <strong>Determine number of columns</strong><br>
        Use UNION probes to match the number of columns in the original SELECT. A one-column UNION probe returned normal content;
        a two-column probe produced a different result (e.g., <em>Game not found</em>), indicating the original query expects <strong>one</strong> column.
      </li>

      <li>
        <strong>Enumerate schema</strong><br>
        Query the information schema to list tables and columns. From these probes the tester discovered a table named <code>users</code>
        and two columns named <code>username</code> and <code>password</code>.
      </li>

      <li>
        <strong>Extract data</strong><br>
        Because the application returned a single column, multiple fields were combined with <code>CONCAT</code> in the UNION projection to return both username and password together in the response.
      </li>
    </ol>

    <h2>Findings</h2>
        <ul>
        <li>The search parameter is vulnerable to UNION-based SQL injection.</li>
        <li>The original SELECT returns <strong>one</strong> column.</li>
        <li>Discovered table: <code>users</code>.</li>
        <li>Discovered columns: <code>username</code> and <code>password</code>.</li>
        <li>Successfully extracted values from the <code>users</code> table using a single-column UNION projection.</li>
        </ul>

    <h2>Proof-of-Concept payloads</h2>

    <h3>Enumerate table names (information_schema)</h3>
    <pre><code class="language-sql">' UNION SELECT table_name FROM information_schema.tables#</code></pre>

    <h3>Enumerate columns for table <code>users</code></h3>
    <pre><code class="language-sql">' UNION SELECT column_name FROM information_schema.columns WHERE table_name='users'#</code></pre>

    <h3>Extract usernames and passwords (concatenated into one column)</h3>
    <pre><code class="language-sql">' UNION SELECT CONCAT(username, ' ', password) FROM users#</code></pre>

    <h2>Ethical & safety note</h2>
    <p>
      Retrieving authentication material (usernames, passwords) is highly sensitive. In a lab or authorized assessment this helps demonstrate impact; in the real world, access to such data can cause significant harm. Always:
    </p>
    <ul>
      <li>Obtain explicit written permission before testing.</li>
      <li>Avoid exposing or publishing real credentials in reports; redact or fake data when sharing publicly.</li>
      <li>Limit tests to non-destructive methods when possible and follow your engagement rules of engagement (RoE).</li>
    </ul>

    <h2>Remediation (prioritized)</h2>
    <ol>
      <li><strong>Parameterize all SQL statements</strong> — never concatenate user input into queries. Use prepared statements or ORM parameter binding.</li>
      <li><strong>Suppress detailed DB error messages</strong> in responses; log full details server-side only.</li>
      <li><strong>Salt and hash passwords</strong> using a modern, slow hashing algorithm (e.g., bcrypt, Argon2). Do not store plaintext passwords.</li>
      <li><strong>Enforce least privilege</strong> for the application database account — it should not need to read metadata or other application users’ data unless required.</li>
      <li><strong>Input validation & output encoding</strong> — apply whitelists, length limits, and context-aware encoding for any reflected content.</li>
      <li><strong>Monitoring and alerting</strong> — detect anomalous queries and repeated failed attempts that might indicate exploitation attempts.</li>
    </ol>

    <h2>Notes & considerations</h2>
    <ul>
      <li>When the original SELECT returns <strong>one</strong> column, any UNION payload must project a single column (or combine multiple fields with <code>CONCAT</code>).</li>
      <li>Comment styles and terminators (e.g., <code>#</code>, <code>--</code>, <code>/* */</code>) vary by DBMS and application; you may need to adapt them.</li>
      <li>Some applications filter or normalize input; payload encoding, spacing or alternative quoting may be required.</li>
      <li>Privilege and schema visibility: not all DB accounts can read <code>information_schema</code>. Limitations vary by DBMS and privileges.</li>
    </ul>
  </div>
</body>
</html>
